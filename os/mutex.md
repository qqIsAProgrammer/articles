# 对锁的一些思考

## 锁的本质

**所谓锁，在计算机里本质上就是一块内存。**这块内存被赋值为 1 代表上锁，被赋值为 0 代表解锁。多个线程抢占一个锁即代表抢着在这块内存上写上 1 。在一个多核环境里，内存空间是共享的。每个核上各跑一个线程，所以硬件必须提供某种 guarantee 来保证一次只有一个线程能成功抢到锁。



## 硬件

CPU 提供一些用来构建锁的 atomic 指令，譬如 x86 的 CMPXCHG（加上 LOCK 前缀），能够完成 atomic 的 compare-and-swap （CAS），用这样的硬件指令就能实现 spin lock 。本质上 LOCK  前缀的作用是锁定系统总线（或者锁定某一块 cache line）来实现 atomicity 。简单来说就是，如果指令前加了 LOCK 前缀，就是告诉其他核，一旦我开始执行这个指令了，在我结束这个指令之前，谁也不许动。缓存一致协议在这里面扮演了重要角色（MESI 协议）。这样便实现了一次只能有一个核对同一个内存地址赋值。



## CAS & MESI

**MESI 协议**的名称由来是指这一协议为缓存的每个数据单位（称为 cache line ，在 Intel CPU 上一般是 64 字节）维护**两个状态位**，使得每个数据单位可能处于 M 、E 、S 或 I 这四种状态之一。各种状态含义如下：

- M : 被修改的。处于这一状态的数据只在本 CPU 中有缓存，且其数据已被修改，没有更新到内存中
- E : 独占的。处于这一状态的数据只在本 CPU 中有缓存，且其数据没有被修改，与内存一致
- S : 共享的。处于这一状态的数据在多个 CPU 中有缓存
- I : 无效的。本 CPU 中的这份缓存已经无效了。

只有缓存状态是 **E 或 M** 时，CPU 才可以修改其中的数据，修改后缓存即处于 **M** 状态。如果 CPU 要修改数据时发现其缓存不处于 E 或 M 状态，则需要发出特殊的 **RFO 指令**（Read For Ownership），将其它 CPU 的缓存设为 **I** 状态。

因此，**如果一个变量在某段时间内只被一个线程频繁修改，则对应的缓存早就处于 M 状态，这时 CAS 操作就不会涉及到总线操作。**所以加锁不一定会影响性能，**锁争用才会**。如果经常出现冲突，即缓存一会被这个 CPU 独占，一会被那个 CPU 独占，这时才会不断产生 RFO ，影响到并发性能。



某博主的解释：

> 在 x86 架构上，当两个 core 同时执行针对同一地址的 CAS 指令时,其实他们是在试图修改每个 core 自己持有的 cache line 。
>
> 假设两个 core 都持有相同地址对应 cache line ，且各自 cache line 状态为 S 。这时如果要想成功修改,就首先需要把 S 转为 E ，则需要向其它 core invalidate 这个地址的 cacheline ，则两个 core 都会向 bus 发出 invalidate 这个操作, 那么在 bus 上就会根据特定的设计协议仲裁是 core0 还是 core1 能赢得这个 invalidate ，胜者完成操作，失败者需要接受结果，invalidate 自己对应的 cache line ，再读取胜者修改后的值，回到起点。
>
> 对于 CAS 操作来说，其实锁并没有消失，只是转嫁到了 bus 的总线仲裁协议中。而且大量的多核同时针对一个地址的 CAS 操作会引起反复的互相 invalidate 同一 cache line ，造成 pingpong 效应，从而会降低性能。



## futex

Spin lock 的实现让没有抢到锁的线程在 while 循环里一直做 CAS ，直至抢到锁的线程释放锁（lock contention），此时 CPU 做的事情就是反复轮询，并且在这个期间是没有 OS 介入的。如果需要等待的时间较长，CPU 反复轮询是比较浪费资源的，此时线程可以向 OS 申请挂起（trap 然后 sleep），直至占有锁的线程释放锁便唤醒挂起的线程。那么此时 CPU 就可以去执行其他线程，提高资源利用率。但是 OS 切换线程是有一定的开销的，所以是否选择被挂起就取决于等待的时间是否比较长。

线程向 OS 申请挂起是通过一个系统调用，在 linux 下的实现是 futex (fast userspace mutex) 。我们需要一个全局的数据结构来记录挂起的线程与锁的映射关系，这样一个数据结构天然是全局的，因为多个 OS 线程可能同时操作它。所以，**实现锁本身也需要锁**（互斥访问全局数据结构）。但 futex 巧妙之处在于：**它知道访问这个全局数据结构不会太耗时，于是 futex 里面的锁就是 spin lock** 。linux 上 pthread mutex 的实现就是用的 futex 。



## 使用 mutex 性能就一定更差吗？

先说结论：不一定，取决于临界区的大小。

在 futex 已经提及到：「futex 知道访问这个全局数据结构不会太耗时，于是 futex 里面的锁就是 spin lock」。但也许你有疑惑：为什么不耗时就使用 spin lock ？

锁指令本身很简单，真正影响性能的是锁争用（lock contention）。什么叫锁争用，就是**所有线程都想进入临界区，但只能有一个线程能进去**，这样就影响了并发度。「只有一个线程在临界区」这件事对 lockfree (CAS) 也是成立的，只不过所有线程都可以进临界区，最后**只有一个线程可以 make progress** ，其它线程再做一遍。

所以 contention 在有锁和无锁编程中都是存在的，他们的不同体现在拿不到锁的态度：**有锁的情况就是 sleep ，无锁的情况就不断 spin** 。但 sleep 这个动作会 trap ，发生 context switch ，这个是有开销的，但是这个开销能有多大呢？**当你的临界区很小的时候，这个开销的比重就非常大**。这也是为什么临界区很小的时候，换成 lockfree 性能通常会提高很多的原因。但是如果 lockfree 的 contention 非常严重，那么 spin 花费的时间会非常长而且非常消耗 CPU 资源，此时性能也许不如 mutex 。

lockfree 的意义不在于绝对的高性能，它比 mutex 的优点是使用 lockfree 可以避免死锁/活锁，优先级翻转等问题。但是因为 ABA problem、memory order 等问题，使得 lockfree 比 mutex 难实现得多。



## 其他一些 high-level 的锁

上述所说的锁是最底层的锁，根据底层锁可以构建一些更高级的锁：RWLock 、Semaphore 、Condition Variable 等。



## 引用

[知乎回答：「互斥锁（mutex）的底层原理是什么？ 操作系统具体是怎么实现的？」](https://www.zhihu.com/question/332113890/answer/1052024052)

[知乎回答：「多线程编程的时候，使用无锁结构会不会比有锁结构更加快？」](https://www.zhihu.com/question/53303879/answer/134936389)

[CAS 指令与 MESI 缓存一致性协议、“轻量级锁”与原子操作](https://developer.aliyun.com/article/626910)

[CPU 缓存一致性协议 MESI 的理解，及 CAS 基于 MESI 的应用](https://blog.csdn.net/caoyu019/article/details/101024617)